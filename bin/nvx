#!/usr/bin/env bash

# nvx - Execute commands with local node_modules/.bin in PATH
# NOTE: This script must be compatible with bash 3.2 (macOS default)

# Helper function to show help text
show_help() {
  cat << EOF
nvx - Execute commands with local node_modules/.bin in PATH

Usage:
  nvx <command> [args...]        Execute command with ./node_modules/.bin in PATH
  nvx --install-to-user          Add nvm/bin to user PATH (current user, works with GUI apps)
  nvx --install-to-system        Add nvm/bin to system PATH (all users, requires sudo)
  nvx --help, -h                 Show this help message

Examples:
  nvx eslint src/                Run eslint from local node_modules
  nvx prettier --write .         Run prettier from local node_modules
  nvx --install-to-user          Install nvm/bin to current user's PATH
  sudo nvx --install-to-system   Install nvm/bin to system PATH (all users)
EOF
}

# Helper function to detect NVM paths
detect_nvm_paths() {
  # Get the directory where this script is located
  SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd -P)"
  # NVM_HOME is the parent directory of bin/
  DETECTED_NVM_HOME="$(dirname "$SCRIPT_DIR")"

  # Use NVM_HOME env var if set, otherwise use detected path
  if [ -n "$NVM_HOME" ]; then
    NVM_BIN_PATH="${NVM_HOME}/bin"
  else
    NVM_BIN_PATH="${DETECTED_NVM_HOME}/bin"
  fi

  # Get NVM_LINK path (linked nodejs version)
  NVM_LINK_PATH="${DETECTED_NVM_HOME}/nodejs/bin"
  if [ -n "$NVM_LINK" ]; then
    NVM_LINK_PATH="$NVM_LINK"
  fi
}

# Check for help flag
if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
  show_help
  exit 0
fi

# Check for --install-to-user flag
if [ "$1" = "--install-to-user" ]; then
  detect_nvm_paths
  OS_TYPE="$(uname)"

  if [ "$OS_TYPE" = "Darwin" ]; then
    # macOS: Add to shell profile files for terminal and update launchctl for GUI apps

    # Find node executable
    NODE_EXE="$DETECTED_NVM_HOME/node"
    if [ ! -f "$NODE_EXE" ]; then
      echo "Error: Node.js executable not found at $NODE_EXE" >&2
      echo "Please install Node.js first with: nvm install lts" >&2
      exit 1
    fi

    # Update shell profiles using install_bashrc.js
    INSTALL_SCRIPT="$DETECTED_NVM_HOME/bin/install_bashrc.js"
    if [ -f "$INSTALL_SCRIPT" ]; then
      # Update .bashrc or .bash_profile
      if [ -f "$HOME/.bashrc" ]; then
        "$NODE_EXE" "$INSTALL_SCRIPT" "$HOME/.bashrc" bash >/dev/null 2>&1
      elif [ -f "$HOME/.bash_profile" ]; then
        "$NODE_EXE" "$INSTALL_SCRIPT" "$HOME/.bash_profile" bash >/dev/null 2>&1
      fi

      # Update .zshrc
      if [ -f "$HOME/.zshrc" ]; then
        "$NODE_EXE" "$INSTALL_SCRIPT" "$HOME/.zshrc" zsh >/dev/null 2>&1
      fi
    fi

    # Update launchctl config for current session and GUI apps
    launchctl setenv PATH "$NVM_BIN_PATH:$(launchctl getenv PATH 2>/dev/null || echo '/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin')"

    # Create LaunchAgent for persistent GUI app support across reboots
    LAUNCH_AGENTS_DIR="$HOME/Library/LaunchAgents"
    PLIST_FILE="$LAUNCH_AGENTS_DIR/com.universal-nvm.plist"
    mkdir -p "$LAUNCH_AGENTS_DIR" 2>/dev/null

    cat > "$PLIST_FILE" << 'PLIST_EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>com.universal-nvm</string>
  <key>ProgramArguments</key>
  <array>
    <string>sh</string>
    <string>-c</string>
    <string>
      CURRENT_PATH=$(launchctl getenv PATH 2>/dev/null)
      if [ -z "$CURRENT_PATH" ]; then
        CURRENT_PATH="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
      fi
      launchctl setenv PATH "NVM_BIN_PLACEHOLDER:NVM_LINK_PLACEHOLDER:$CURRENT_PATH"
    </string>
  </array>
  <key>RunAtLoad</key>
  <true/>
</dict>
</plist>
PLIST_EOF

    # Replace placeholders with actual paths
    sed -i '' "s|NVM_BIN_PLACEHOLDER|$NVM_BIN_PATH|g" "$PLIST_FILE"
    sed -i '' "s|NVM_LINK_PLACEHOLDER|$NVM_LINK_PATH|g" "$PLIST_FILE"

    launchctl unload "$PLIST_FILE" 2>/dev/null
    launchctl load "$PLIST_FILE" 2>/dev/null

    echo "Successfully configured user PATH"
    echo "Added $NVM_BIN_PATH to:"
    echo "  - Current session (immediate effect)"
    echo "  - Shell profiles (terminal sessions)"
    echo "  - LaunchAgent at $PLIST_FILE (GUI apps after login)"
    echo ""
    echo "The PATH is now active for new terminal windows and current GUI apps."
    echo "For full GUI app support, log out and log back in."
    exit 0

  elif [ "$OS_TYPE" = "Linux" ]; then
    # Linux: Use systemd user environment.d
    SYSTEMD_ENV_DIR="$HOME/.config/environment.d"
    ENV_FILE="$SYSTEMD_ENV_DIR/10-jchip-universal-nvm.conf"

    # Check if already installed
    if [ -f "$ENV_FILE" ] && grep -q "$NVM_BIN_PATH" "$ENV_FILE" 2>/dev/null; then
      echo "$NVM_BIN_PATH is already in user PATH"
      exit 0
    fi

    # Create directory if it doesn't exist
    mkdir -p "$SYSTEMD_ENV_DIR" 2>/dev/null

    # Create the environment file with both paths
    cat > "$ENV_FILE" << ENV_EOF
# universal-nvm environment configuration
# Adds nvm/bin and nodejs/bin to PATH for GUI applications
PATH=$NVM_BIN_PATH:$NVM_LINK_PATH:\$PATH
ENV_EOF

    if [ $? -eq 0 ]; then
      echo "Successfully configured user PATH"
      echo "Created environment file at $ENV_FILE"
      echo "Added paths:"
      echo "  - $NVM_BIN_PATH (nvm commands)"
      echo "  - $NVM_LINK_PATH (node/npm)"
      echo ""
      echo "Log out and log back in for changes to take effect"
      exit 0
    else
      echo "Error: Failed to create environment file" >&2
      exit 1
    fi

  else
    echo "Error: --install-to-user is only supported on macOS and Linux" >&2
    echo "Detected OS: $OS_TYPE" >&2
    exit 1
  fi
fi

# Check for --install-to-system flag
if [ "$1" = "--install-to-system" ]; then
  detect_nvm_paths
  SCRIPT_PATH="$(cd "$(dirname "$0")" && pwd -P)/$(basename "$0")"
  OS_TYPE="$(uname)"

  if [ "$OS_TYPE" = "Darwin" ]; then
    # macOS: use /etc/paths.d
    PATHS_DIR="/etc/paths.d"
    PATHS_FILE="$PATHS_DIR/999-uni-nvm"

    # Check if /etc/paths.d exists
    if [ ! -d "$PATHS_DIR" ]; then
      echo "Error: $PATHS_DIR directory does not exist" >&2
      echo "" >&2
      echo "This feature requires /etc/paths.d which is standard on macOS." >&2
      echo "Please ensure you are running a standard macOS installation." >&2
      exit 1
    fi

    # Try to write to /etc/paths.d/
    if echo "$NVM_BIN_PATH" > "$PATHS_FILE" 2>/dev/null; then
      echo "Successfully installed to system PATH"
      echo "Added $NVM_BIN_PATH to $PATHS_FILE"
      echo "You may need to restart your terminal for changes to take effect"
      exit 0
    else
      echo "Error: Permission denied writing to $PATHS_FILE" >&2
      echo "" >&2
      echo "Please run this command with sudo:" >&2
      echo "  sudo \"$SCRIPT_PATH\" --install-to-system" >&2
      exit 1
    fi

  elif [ "$OS_TYPE" = "Linux" ]; then
    # Linux: update /etc/environment for system-wide PATH (works for GUI apps too)
    ENV_FILE="/etc/environment"

    if [ ! -f "$ENV_FILE" ]; then
      echo "Error: $ENV_FILE does not exist" >&2
      echo "" >&2
      echo "This feature requires /etc/environment which is standard on most Linux distributions." >&2
      exit 1
    fi

    # Check if already in /etc/environment
    if grep -q "$NVM_BIN_PATH" "$ENV_FILE" 2>/dev/null; then
      echo "$NVM_BIN_PATH is already in system PATH"
      exit 0
    fi

    # Read current PATH from /etc/environment
    CURRENT_PATH=$(grep -E '^PATH=' "$ENV_FILE" 2>/dev/null | sed 's/^PATH=//' | sed 's/"//g')

    if [ -z "$CURRENT_PATH" ]; then
      # No PATH line exists, create one
      NEW_PATH_LINE="PATH=\"$NVM_BIN_PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\""
    else
      # PATH exists, prepend our path
      NEW_PATH_LINE="PATH=\"$NVM_BIN_PATH:$CURRENT_PATH\""
    fi

    # Create a temporary file with the updated content
    TMP_FILE=$(mktemp 2>/dev/null) || TMP_FILE="/tmp/uni-nvm-env.$$"

    if grep -v -E '^PATH=' "$ENV_FILE" > "$TMP_FILE" 2>/dev/null && echo "$NEW_PATH_LINE" >> "$TMP_FILE" 2>/dev/null; then
      # Try to write back to /etc/environment
      if cat "$TMP_FILE" > "$ENV_FILE" 2>/dev/null; then
        rm -f "$TMP_FILE"
        echo "Successfully installed to system PATH"
        echo "Added $NVM_BIN_PATH to $ENV_FILE"
        echo "You may need to log out and log back in for changes to take effect"
        exit 0
      else
        rm -f "$TMP_FILE"
        echo "Error: Permission denied writing to $ENV_FILE" >&2
        echo "" >&2
        echo "Please run this command with sudo:" >&2
        echo "  sudo \"$SCRIPT_PATH\" --install-to-system" >&2
        exit 1
      fi
    else
      rm -f "$TMP_FILE" 2>/dev/null
      echo "Error: Failed to update $ENV_FILE" >&2
      exit 1
    fi

  else
    echo "Error: --install-to-system is only supported on macOS and Linux" >&2
    echo "Detected OS: $OS_TYPE" >&2
    exit 1
  fi
fi

# Check if there are no remaining arguments - show help
if [ $# -eq 0 ]; then
  echo "Error: nvx requires a command to execute" >&2
  echo "" >&2
  show_help
  exit 1
fi

# Check if ./node_modules/.bin exists
if [ -d "./node_modules/.bin" ]; then
  # Resolve to absolute path using cd and pwd
  BIN_PATH="$(cd "./node_modules/.bin" 2>/dev/null && pwd -P)"

  # If we got an absolute path, use it; otherwise fall back to relative
  if [ -n "$BIN_PATH" ]; then
    export PATH="$BIN_PATH:$PATH"
  else
    # Fallback to relative path if absolute resolution fails
    # (shouldn't happen if directory exists, but handle it just in case)
    export PATH="./node_modules/.bin:$PATH"
  fi
fi


# Execute the remaining arguments as a command
# On Windows, prefer .cmd files over bash scripts for extensionless commands
CMD_NAME="$1"
shift

# Check if we're on Windows by checking OSTYPE (msys/cygwin/mingw) or WINDIR
IS_WINDOWS=0
case "$OSTYPE" in
  msys*|cygwin*|mingw*)
    IS_WINDOWS=1
    ;;
esac
if [ -n "$WINDIR" ]; then
  IS_WINDOWS=1
fi

if [ "$IS_WINDOWS" = "1" ]; then
  # Check if the command already has an extension (e.g., script.js, tool.sh)
  case "$CMD_NAME" in
    *.*)
      # Has extension - skip .cmd lookup
      ;;
    *)
      # No extension - try to find .cmd version first
      CMD_PATH=$(command -v "${CMD_NAME}.cmd" 2>/dev/null)
      if [ -n "$CMD_PATH" ]; then
        exec "$CMD_PATH" "$@"
      fi
      ;;
  esac
fi

# Fall back to original command
exec "$CMD_NAME" "$@"

